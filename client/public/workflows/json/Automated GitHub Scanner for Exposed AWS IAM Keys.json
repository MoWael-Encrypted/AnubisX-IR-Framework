{
  "name": "Automated GitHub Scanner for Exposed AWS IAM Keys",
  "nodes": [
    {
      "parameters": {},
      "id": "03c6c238-e3d8-4900-a25e-b7bcb3c6db45",
      "name": "When clicking â€˜Execute workflowâ€™",
      "type": "n8n-nodes-base.manualTrigger",
      "position": [
        -112,
        560
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "b9f2076f-0327-47d3-baae-acfece409992",
      "name": "Split Users for Processing",
      "type": "n8n-nodes-base.splitInBatches",
      "position": [
        560,
        560
      ],
      "typeVersion": 3
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://iam.amazonaws.com",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "aws",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "Action",
              "value": "ListAccessKeys"
            },
            {
              "name": "Version",
              "value": "2010-05-08"
            },
            {
              "name": "UserName",
              "value": "={{ $json.username }}"
            }
          ]
        },
        "options": {}
      },
      "id": "a57aeb72-743f-43fd-a8ff-87b1ce6113f8",
      "name": "Get User Access Keys",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        784,
        480
      ],
      "typeVersion": 4.1
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 1,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "active-key-check",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "leftValue": "={{ $json.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata[0].Status }}",
              "rightValue": "Active"
            }
          ]
        },
        "options": {}
      },
      "id": "8d6853c5-8adb-4f2d-b9c4-96d0c8426af6",
      "name": "Filter Active Keys Only",
      "type": "n8n-nodes-base.if",
      "position": [
        992,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "url": "={{ $json.simpleSearch.searchUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 10000
        }
      },
      "id": "113d8344-5ae9-47e9-bd98-8434295a0fd1",
      "name": "Search GitHub for Exposed Keys",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        1664,
        480
      ],
      "typeVersion": 4.1
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all search results\nconst allResults = [];\nconst accessKeyId = $input.first().json.accessKeyId;\nconst userName = $input.first().json.userName;\n\nfor (const item of $input.all()) {\n  if (item.json.total_count > 0) {\n    allResults.push(...item.json.items);\n  }\n}\n\n// Remove duplicates based on repository and file path\nconst uniqueResults = allResults.filter((item, index, self) => \n  index === self.findIndex(t => t.repository.full_name === item.repository.full_name && t.path === item.path)\n);\n\nreturn [{\n  accessKeyId,\n  userName,\n  totalMatches: uniqueResults.length,\n  repositories: uniqueResults,\n  isCompromised: uniqueResults.length > 0\n}];"
      },
      "id": "8c21e5a6-2b7c-4f09-80c0-468e7482a37a",
      "name": "Aggregate Search Results",
      "type": "n8n-nodes-base.code",
      "position": [
        1872,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "loose"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "ebf33a67-f8f3-4700-8579-1d33b7a642d5",
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "leftValue": "isCompromised",
              "rightValue": "={{ $json.isCompromised }}"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "id": "58d6fd1a-8ab3-4f4b-8745-152be61ee5f2",
      "name": "Check For Compromised Keys",
      "type": "n8n-nodes-base.if",
      "position": [
        2096,
        480
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "jsCode": "// Generate comprehensive security report - Notification Only (No Automatic Actions)\nconst data = $input.item.json;\n\nconst report = {\n  timestamp: new Date().toISOString(),\n  accessKeyId: data.accessKeyId,\n  userName: data.userName,\n  status: data.isCompromised ? 'COMPROMISED' : 'SAFE',\n  totalRepositories: data.totalMatches,\n  repositories: data.repositories.map(repo => ({\n    name: repo.repository.full_name,\n    url: repo.html_url,\n    path: repo.path,\n    score: repo.score\n  })),\n  actionTaken: data.isCompromised ? 'Security team notified - Manual review required' : 'No action required',\n  riskLevel: data.totalMatches > 5 ? 'HIGH' : data.totalMatches > 0 ? 'MEDIUM' : 'LOW',\n  notificationSent: data.isCompromised ? true : false,\n  requiresManualAction: data.isCompromised ? true : false,\n  recommendedActions: data.isCompromised ? [\n    'Manually disable the compromised access key',\n    'Generate new access keys for affected services',\n    'Remove exposed keys from repositories',\n    'Audit recent API usage for this key'\n  ] : []\n};\n\nreturn [report];"
      },
      "id": "75ba6ee6-7839-4d71-a868-719cfdcddf20",
      "name": "Generate Security Report",
      "type": "n8n-nodes-base.code",
      "position": [
        2320,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {},
      "id": "8277c9cb-269f-499a-98cc-dac7073eba09",
      "name": "Continue Scanning",
      "type": "n8n-nodes-base.noOp",
      "position": [
        3120,
        560
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "mode": "id",
          "value": "C08Q2H8SRUP"
        },
        "text": "={{ $json.message }}",
        "otherOptions": {}
      },
      "id": "545294fb-ebbf-40c8-b144-3f7bd38c1f29",
      "name": "Slack",
      "type": "n8n-nodes-base.slack",
      "position": [
        2800,
        480
      ],
      "webhookId": "47dc1fb0-71c0-40f6-8263-88880f01a436",
      "typeVersion": 2.3
    },
    {
      "parameters": {
        "jsCode": "/**\n * GitHub Scanner for Exposed AWS IAM Keys - Data Processor\n * \n * This script processes the results from the AWS IAM Key scanner workflow\n * and formats them for reporting and notification purposes.\n */\n\n// Main entry point - this is what n8n will call\n// Input: items array from n8n workflow\n// Output: Slack Block Kit UI format (blocks array only)\nconst items = $input.all();\n\n// Process the input data\nconst scanResults = items.map(item => item.json);\nconst processedResults = processIAMScanResults(scanResults);\n\n// Format for markdown notification\nconst markdownNotification = formatForMarkdownNotification(processedResults);\n// Return as array of objects for n8n\nreturn [{ message: markdownNotification }];\n\n/**\n * Process scan results and format them for reporting\n * @param {Array} scanResults - Array of scan result objects from the workflow\n * @returns {Array} Array of formatted result objects\n */\nfunction processIAMScanResults(scanResults) {\n  if (!Array.isArray(scanResults) || scanResults.length === 0) {\n    return [{\n      status: 'NO_RESULTS',\n      timestamp: new Date().toISOString(),\n      message: 'No scan results to process'\n    }];\n  }\n\n  // Process each scan result\n  const processedResults = scanResults.map(result => {\n    // Create a deep copy to avoid modifying the original data\n    const processedResult = JSON.parse(JSON.stringify(result));\n    \n    // Ensure we have the required fields\n    if (!processedResult.timestamp) {\n      processedResult.timestamp = new Date().toISOString();\n    }\n    \n    // Calculate risk metrics if not provided\n    if (!processedResult.riskLevel) {\n      processedResult.riskLevel = calculateRiskLevel(processedResult);\n    }\n    \n    // Generate recommended actions if not provided\n    if (!processedResult.recommendedActions || processedResult.recommendedActions.length === 0) {\n      processedResult.recommendedActions = generateRecommendedActions(processedResult);\n    }\n    \n    return processedResult;\n  });\n\n  return processedResults;\n}\n  \n  /**\n   * Calculate risk level based on scan result data\n   * @param {Object} result - Individual scan result\n   * @returns {string} Risk level (HIGH, MEDIUM, LOW)\n   */\n  function calculateRiskLevel(result) {\n    // Default to MEDIUM if we can't determine\n    if (!result || !result.status) {\n      return 'MEDIUM';\n    }\n    \n    // Determine risk level based on status and other factors\n    if (result.status === 'COMPROMISED') {\n      // Public repositories or repositories with many contributors increase risk\n      if (result.repositories && result.repositories.some(repo => {\n        return repo.score >= 0.8; // High score indicates higher risk\n      })) {\n        return 'HIGH';\n      }\n      return 'MEDIUM';\n    } else if (result.status === 'POTENTIAL_EXPOSURE') {\n      return 'MEDIUM';\n    } else {\n      return 'LOW';\n    }\n  }\n  \n  /**\n   * Generate recommended actions based on scan result\n   * @param {Object} result - Individual scan result\n   * @returns {Array} List of recommended actions\n   */\n  function generateRecommendedActions(result) {\n    const commonActions = [\n      'Review the exposure details in the security report',\n      'Rotate affected access keys immediately'\n    ];\n    \n    if (result.status === 'COMPROMISED') {\n      return [\n        ...commonActions,\n        'Disable the compromised access key',\n        'Generate new access keys for affected services',\n        'Remove exposed keys from repositories',\n        'Audit recent API usage for this key'\n      ];\n    } else if (result.status === 'POTENTIAL_EXPOSURE') {\n      return [\n        ...commonActions,\n        'Verify if the exposure is a false positive',\n        'Consider rotating keys as a precaution'\n      ];\n    } else {\n      return [\n        'No immediate action required',\n        'Continue monitoring for potential exposures'\n      ];\n    }\n  }\n  \n  /**\n   * Format scan results for Slack-compatible markdown notification\n   * @param {Array} processedResults - Processed scan results\n   * @returns {string} Slack-compatible markdown formatted notification text\n   */\n  function formatForMarkdownNotification(processedResults) {\n    if (!Array.isArray(processedResults) || processedResults.length === 0) {\n      return `ðŸ”’ *AWS IAM Key Scan Completed*\\n\\nNo exposed AWS IAM keys were detected in this scan.`;\n    }\n  \n    // Count compromised keys\n    const compromisedCount = processedResults.filter(r => r.status === 'COMPROMISED').length;\n    \n    if (compromisedCount === 0) {\n      return `ðŸ”’ *AWS IAM Key Scan Completed*\\n\\nNo exposed AWS IAM keys were detected in this scan.`;\n    }\n    \n    // Create Slack-compatible notification for compromised keys\n    let markdown = `âš ï¸ *ALERT: AWS IAM Keys Exposed*\\n\\n*${compromisedCount}* AWS IAM keys have been potentially exposed on GitHub. Immediate action required.\\n\\n`;\n    \n    // Add details for each compromised key\n    processedResults.filter(r => r.status === 'COMPROMISED').forEach((result, index) => {\n      markdown += `*Exposure ${index + 1}*\\n\\n`;\n      \n      // Add repository information in a cleaner format\n      markdown += `*Exposure Details:*\\n`;\n      result.repositories.forEach(repo => {\n        markdown += `â€¢ *Repository:* ${repo.name}\\n`;\n        markdown += `â€¢ *Path:* \\`${repo.path}\\`\\n`;\n        markdown += `â€¢ *Risk Score:* ${repo.score.toFixed(2)}\\n\\n`;\n      });\n      \n      // Add risk level and action taken in a compact format\n      markdown += `*Risk Level:* ${result.riskLevel} | *Action Taken:* ${result.actionTaken || 'None'}\\n\\n`;\n      \n      // Add recommended actions with better formatting\n      markdown += `*Recommended Actions:*\\n`;\n      result.recommendedActions.forEach(action => {\n        markdown += `â€¢ ${action}\\n`;\n      });\n      markdown += `\\n`;\n    });\n    \n    return markdown;\n  }\n\n  \n  // Export functions for use in n8n workflow\n  module.exports = {\n    processIAMScanResults,\n    calculateRiskLevel,\n    generateRecommendedActions,\n    formatForMarkdownNotification\n  };"
      },
      "id": "cc224e48-9dba-49c7-b1a8-b81d4c776621",
      "name": "Format Slack Alert",
      "type": "n8n-nodes-base.code",
      "position": [
        2544,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "/**\n * Simplified GitHub Search for AWS Access Keys\n * This script generates optimized search queries for finding exposed AWS access keys on GitHub\n */\n\n/**\n * Generates a GitHub API search URL for a given AWS access key\n * @param {Object} inputData - The input data containing AWS access key information\n * @returns {Object} - Search information including URL and query\n */\nfunction generateGitHubSearchQuery(inputData) {\n  try {\n    // Extract access key information from input\n    let accessKeyId;\n    let userName;\n    \n    // Handle different input formats\n    if (inputData && typeof inputData === 'object') {\n      // Check for n8n workflow format\n      if (inputData.ListAccessKeysResponse && \n          inputData.ListAccessKeysResponse.ListAccessKeysResult && \n          inputData.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata && \n          Array.isArray(inputData.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata) && \n          inputData.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata.length > 0) {\n        \n        accessKeyId = inputData.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata[0].AccessKeyId;\n        userName = inputData.ListAccessKeysResponse.ListAccessKeysResult.AccessKeyMetadata[0].UserName;\n      } \n      // Direct object format\n      else if (inputData.accessKeyId) {\n        accessKeyId = inputData.accessKeyId;\n        userName = inputData.userName || 'unknown';\n      }\n    }\n    \n    // Validate we have an access key\n    if (!accessKeyId) {\n      console.error('No valid AWS access key ID found in input');\n      return { error: 'No valid AWS access key ID found in input' };\n    }\n    \n    // Create the most effective search query\n    // Based on testing, the exact match with quotes is most reliable\n    const searchQuery = `\"${accessKeyId}\" in:file`;\n    \n    // Generate the GitHub API search URL\n    const searchUrl = `https://api.github.com/search/code?q=${encodeURIComponent(searchQuery)}`;\n    \n    return {\n      accessKeyId,\n      userName,\n      searchQuery,\n      searchUrl,\n      note: 'A single exact match query is typically sufficient for finding exposed AWS keys'\n    };\n  } catch (error) {\n    console.error('Error generating GitHub search query:', error);\n    return { error: `Error generating GitHub search query: ${error.message}` };\n  }\n}\n\n/**\n * For more comprehensive searches, this function generates multiple search patterns\n * This is optional and can be used if the simple search doesn't yield results\n * @param {string} accessKeyId - The AWS access key ID to search for\n * @returns {Array} - Array of search queries and URLs\n */\nfunction generateComprehensiveSearch(accessKeyId) {\n  if (!accessKeyId) {\n    return { error: 'No access key ID provided' };\n  }\n  \n  // Search patterns for access keys (in order of effectiveness)\n  const searchQueries = [\n    `\"${accessKeyId}\" in:file`,           // Exact match (most effective)\n    `${accessKeyId} in:file`,              // Without quotes (catches more results but may have false positives)\n    `AWS_ACCESS_KEY_ID=${accessKeyId} in:file`,  // Environment variable format\n    `aws_access_key_id: ${accessKeyId} in:file`, // YAML/config format\n    `accessKeyId: ${accessKeyId} in:file`        // JavaScript/JSON format\n  ];\n  \n  return searchQueries.map(query => ({\n    searchQuery: query,\n    searchUrl: `https://api.github.com/search/code?q=${encodeURIComponent(query)}`\n  }));\n}\n\n// For n8n integration\nfunction processForN8n() {\n  try {\n    // Get input data\n    const inputData = $input.item.json;\n    \n    // Generate the simplified search (recommended approach)\n    const simpleSearch = generateGitHubSearchQuery(inputData);\n    \n    // For backward compatibility, also generate the comprehensive search\n    // if an access key was successfully extracted\n    let comprehensiveSearch = [];\n    if (simpleSearch.accessKeyId) {\n      comprehensiveSearch = generateComprehensiveSearch(simpleSearch.accessKeyId);\n    }\n    \n    return {\n      simpleSearch,\n      comprehensiveSearch,\n      recommendation: 'The simple search is recommended for most cases. Only use comprehensive search if simple search yields no results.'\n    };\n  } catch (error) {\n    console.error('Error in n8n processing:', error);\n    return { error: `Error in n8n processing: ${error.message}` };\n  }\n}\n\n// For standalone usage\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    generateGitHubSearchQuery,\n    generateComprehensiveSearch\n  };\n} else {\n  // For n8n execution\n  return processForN8n();\n}"
      },
      "id": "e8ee4796-cb42-44c6-97e9-555520b3c92d",
      "name": "Prepare Github Search",
      "type": "n8n-nodes-base.code",
      "position": [
        1216,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "content": "# ðŸ”ðŸ•µï¸â€â™‚ï¸ GitHub Scanner for Exposed AWS IAM Keys â€“ Quick Overview\n\n## âš™ï¸ Workflow at a Glance\n\n1. ðŸ” **Automated Discovery**  \n   Scans GitHub repositories for exposed AWS IAM access keys associated with your AWS account.\n\n2. ðŸ§  **Intelligent Filtering**  \n   Processes only active access keys and eliminates duplicate findings.\n\n3. ðŸš¨ **Risk Assessment**  \n   Evaluates exposure severity and assigns risk levels (High/Medium/Low) based on findings.\n\n4. ðŸ“£ **Actionable Alerts**  \n   Sends detailed Slack notifications with interactive buttons for immediate response.\n\n5. ðŸ› ï¸ **Remediation Guidance**  \n   Provides step-by-step instructions for securing compromised credentials.\n\n6. ðŸ”„ **Continuous Monitoring**  \n   Maintains ongoing surveillance to detect new exposures quickly.\n\n---\n\n*ðŸ›¡ï¸ This workflow helps security teams quickly identify and respond to potential security breaches from exposed AWS credentials.*\n",
        "height": 580,
        "width": 1120
      },
      "id": "adaa026c-565e-4b46-9056-a5532919f07b",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -128,
        -208
      ],
      "typeVersion": 1
    },
    {
      "parameters": {},
      "id": "54bd2f33-28c4-4bac-abc9-32950816c87b",
      "name": "Rate Limit Wait",
      "type": "n8n-nodes-base.wait",
      "position": [
        1440,
        480
      ],
      "webhookId": "850e337e-d261-456a-86c1-1725d77f9e52",
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://iam.amazonaws.com",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "aws",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "Action",
              "value": "ListUsers"
            },
            {
              "name": "Version",
              "value": "2010-05-08"
            }
          ]
        },
        "options": {}
      },
      "id": "498bfaa7-1c41-48eb-ad62-15897ca262bc",
      "name": "List AWS Users1",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        112,
        560
      ],
      "typeVersion": 4.1
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node: Extract usernames from AWS ListUsersResponse\n\nconst allInputs = $input.all();\n\n// Find the ListUsersResponse input\nconst listUsersInput = allInputs.find(item => item.json.ListUsersResponse);\n\nif (!listUsersInput) {\n  throw new Error('No ListUsersResponse found in input data');\n}\n\n// Extract users array from the response\nconst users = listUsersInput.json\n  .ListUsersResponse\n  .ListUsersResult\n  .Users || [];\n\n// Extract usernames and return each as a separate item for looping\nconst usernameItems = users.map(user => ({\n  json: { username: user.UserName }\n}));\n\n// Return array of individual username objects\nreturn usernameItems;"
      },
      "id": "149a4e66-ff96-49f0-9014-609ff6990824",
      "name": "Extract AWS Usernames",
      "type": "n8n-nodes-base.code",
      "position": [
        336,
        560
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://iam.amazonaws.com",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "aws",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "Action",
              "value": "UpdateAccessKey"
            },
            {
              "name": "AccessKeyId",
              "value": "AKIAEXAMPLEACCESSKEY1"
            },
            {
              "name": "UserName",
              "value": "user@domain.com"
            },
            {
              "name": "Status",
              "value": "Inactive"
            },
            {
              "name": "Version",
              "value": "2010-05-08"
            }
          ]
        },
        "options": {}
      },
      "id": "80dd5d90-971a-4bc3-b97c-eb687d50f658",
      "name": "Disable Access Keys",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        1984,
        -144
      ],
      "typeVersion": 4.1,
      "disabled": true
    },
    {
      "parameters": {
        "content": "## ðŸš¨ Automate Disable Access Keys\n\n### 1. Prerequisites\n\n- Configure AWS credentials in n8n with appropriate IAM permissions  \n- Create an `Extract_Key_Info` node that provides the compromised key's ID and username  \n\n### 2. Workflow Integration\n\n- Add this node after your key detection logic  \n- Connect it to trigger when a compromised key is confirmed  \n\n### 3. Security Considerations\n\n- Ensure your AWS credentials have the `iam:UpdateAccessKey` permission  \n- Consider adding verification steps before automatic disabling  \n- Implement notification steps after key disabling (e.g., Slack, email)  \n\n---\n\nThis implementation enables **immediate remediation of security risks** by automatically disabling compromised AWS access keys as soon as they're discovered in GitHub repositories.\n",
        "height": 580,
        "width": 1200,
        "color": 6
      },
      "id": "844280a8-efb8-479b-8bfd-99038449dcf5",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1024,
        -208
      ],
      "typeVersion": 1
    }
  ],
  "pinData": {},
  "connections": {
    "Slack": {
      "main": [
        [
          {
            "node": "Continue Scanning",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List AWS Users1": {
      "main": [
        [
          {
            "node": "Extract AWS Usernames",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Wait": {
      "main": [
        [
          {
            "node": "Search GitHub for Exposed Keys",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Scanning": {
      "main": [
        [
          {
            "node": "Split Users for Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Slack Alert": {
      "main": [
        [
          {
            "node": "Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Access Keys": {
      "main": [
        [
          {
            "node": "Filter Active Keys Only",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract AWS Usernames": {
      "main": [
        [
          {
            "node": "Split Users for Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Github Search": {
      "main": [
        [
          {
            "node": "Rate Limit Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Active Keys Only": {
      "main": [
        [
          {
            "node": "Prepare Github Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Search Results": {
      "main": [
        [
          {
            "node": "Check For Compromised Keys",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Security Report": {
      "main": [
        [
          {
            "node": "Format Slack Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check For Compromised Keys": {
      "main": [
        [
          {
            "node": "Generate Security Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Users for Processing": {
      "main": [
        [],
        [
          {
            "node": "Get User Access Keys",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search GitHub for Exposed Keys": {
      "main": [
        [
          {
            "node": "Aggregate Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking â€˜Execute workflowâ€™": {
      "main": [
        [
          {
            "node": "List AWS Users1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8f7b4a69-4f6f-4d9d-a816-1450d096f55a",
  "meta": {
    "instanceId": "2e054795eb266fa430683bb616f3e195ac30a3ed41cf98309fb965ae2fab7aba"
  },
  "id": "7YWIOOnOJnZfLwvu",
  "tags": []
}